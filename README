	TASK1 - In prima etapa a programului trebuie sa generez numele outputului care se bazeaza pe numele fisierului din input. Astfel prin functiile Name Output.., despart strigul reprezentat de numele fisierului dupa./ si extrag astfel denumirea boardului de care am nevoie pt generarea corecta a numelui fisierului de output. Fisierul primit ca input este transformat in string prin functia ConverInputtoString si trimis ca parametru functiei cJSON_Parse() care creeaza obiectul de tip json pe baza caruia vom extrage campurile pt a completa structurile bitmap-ului. Functiile ReadDataHeader si ReadDataInfo imi extrag subcampurile/item-urile cJSON-ului si completeaza campurile din structurile aferente. Functia ReadBitMap imi creeaza matricea bitmap prin extragerea elementelor vectorului din cJSON cu cJSON_GetArrayItem si imi seteaza padding -ul in functie de dimensiunea matricei. Toate informatiile se scriu mai apoi in fisierul de output in ordinea ceruta si se obtine astfel imaginea dorita.

	TASK2 - Taskul 2 se oglindesc numerele care se afla in formatul de la taskul1. Pentru aceasta tinem cont de faptul ca numerele in format digital si care indeplinesc format sudoku sunt simetrice in cazul in care pe linie se afla mai mult de 2 biti ceea ce presupune ca este suficienta interschimbarea primului bit cu ultimul de pe fiecare linie din celula 5x5(rezultata prin eliminarea conturului) pentru a obtine functia dorita. Astfel functia MapSwap potriveste matricea prin flip-uirea fiecarei celule, adica a primului bit de pe fiecare linie a celulei.

	TASK3 - Taskul 3 are la baza identificarea numerelor din imaginea bmp obtinuta la taskurile anterioare. Astfel ca printr-o parcurgere a casutelor matricii identificam cu functia FindNumberCell, nr aferent. Acest lucru se realizeaza observand ca fiecare cifra in format digital este unic determinata de 5 biti care anticipiaza forma structurii. Astfel ca considerand bitul0 = bit de pe linia 0 col 0
		bitul1= bit de pe linia 1 col 0
		bitul2 = bit de pe linia 1 col 4
		bitul3 = bit de pe linia 3 col 0
		bitul5 = bit de pe linia 4 col 0 putem sa controlam prin if-uri succesive ce numere sunt reprezentate.    bit0 * * * * 
					      bit1 * * * bit2
					        *  * * *  *
					      bit3 * * *  *
					      bit5 * * *  *
De exemplu: bit-ul0 e alb numai la 1 sau nimic(0)
	    bit-ul1 e alb numai la 2 3 sau 7(l-am exclus pe 1 din prima conditie). Dupa ce am format pseudo matricea de int -uri, verificam sa fie respectate regulile sudoku prin functiile NumberInLine NumberInColumn si NumberInBox care contorizeaza aparitia unei cifre pe linie/coloana/celula. In cazul in care regula este respectata si toate cifrele apar o singura data pe linii/coloane/celula se salveaza mesajul corect intr-un string care se transmite ca parametru. Se creeaza mai apoi un obiect de tip cJSON dupa modelul cerut si se adauga stringul returnat din functia CheckMap ca item obiectului.

	TASK4 - se citeste fisierul binar reprezentat de poza si se completeaza campurile structurii bitmap, si matricea cu care vom lucra. Functia SolveSudoku completeaza pseudo matricea de int-uri si verifica mai apoi la primul spatiu gasit(echivalentul 0 ului din matricea de inti) care nr nu apare scris pe linie/coloana/celula. Cand se gaseste se scrie valoarea in matricea bitmap prin functia FillCell care face corespondenta dintre nr si codificarile acestora care sunt reprezentate de niste stringuri in care * semnifica un pixel colorat si 0 un pixel alb. In functie de nr de aparitii ale *-urilor din codificare se completeaza la rand cate 3 biti in matricea mare cu valorile corespunzatoare culorii magenta. Codificarea parcurge matricea de 5X5 pe linii.  Dupa ce se obtin toate informatiile necesare se scriu datele despre viitoarea poza in fisierul out si se elibereaza memoria 
   